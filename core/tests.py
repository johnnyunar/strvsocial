import shutil

from django.conf import settings
from django.contrib.auth import get_user_model
from django.core.management import call_command
from django.test import TestCase, Client, override_settings
from django.urls import reverse

from core.models import ContentPost

User = get_user_model()

class BaseTestCase(TestCase):
    @classmethod
    def setUpClass(cls) -> None:
        call_command("collectstatic", "--noinput")

    @classmethod
    def tearDownClass(cls):
        shutil.rmtree(settings.STATIC_ROOT)

class HomeViewTests(BaseTestCase):
    def setUp(self) -> None:
        # Create two users: one for the active user and one for a "similar" content owner.
        self.active_user = User.objects.create_user(
            email="active@example.com", username="active", password="password"
        )
        self.other_user = User.objects.create_user(
            email="other@example.com", username="other", password="password"
        )
        # Create a content post for active user (with dummy embedding) and one for other user.
        self.active_post = ContentPost.objects.create(
            user=self.active_user,
            title="Active Post",
            embedding=[0.1, 0.2, 0.3],
        )
        self.other_post = ContentPost.objects.create(
            user=self.other_user,
            title="Other User Post",
            embedding=[0.4, 0.5, 0.6],
        )

        # For testing suggested content, we monkeypatch active_post.get_similar_posts.
        # When called, it will return a list containing the other user's post.
        self.active_post.get_similar_posts = lambda **kwargs: [self.other_post]

        self.client = Client()

    def test_home_view_anonymous(self) -> None:
        """
        Anonymous users should receive fallback context with all content
        and most active users.
        """
        response = self.client.get(reverse("home"))
        self.assertEqual(response.status_code, 200)
        # Fallback context keys.
        self.assertIn("content", response.context)
        self.assertIn("users", response.context)
        # Suggested content should not be in context.
        self.assertNotIn("suggested_content", response.context)

    def test_home_view_authenticated_no_suggestions(self) -> None:
        """
        Authenticated user with no similar posts (i.e. get_similar_posts returns empty)
        should fall back to general content.
        """
        self.client.login(email="active@example.com", password="password")
        # Monkeypatch get_similar_posts to return empty list.
        self.active_post.get_similar_posts = lambda **kwargs: []
        response = self.client.get(reverse("home"))
        self.assertEqual(response.status_code, 200)
        # Fallback context is used.
        self.assertIn("content", response.context)
        self.assertIn("users", response.context)
        self.assertNotIn("suggested_content", response.context)


class ProfileDetailViewTests(BaseTestCase):
    def setUp(self) -> None:
        self.user = User.objects.create_user(
            email="profile@example.com", username="profileuser", password="password"
        )
        self.client = Client()

    def test_profile_detail_view(self) -> None:
        """
        The profile detail view should return the correct user in context.
        """
        url = reverse("profile-detail", kwargs={"username": self.user.username})
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context.get("profile"), self.user)


class ContentPostDetailViewTests(BaseTestCase):
    def setUp(self) -> None:
        self.user = User.objects.create_user(
            email="postdetail@example.com", username="postuser", password="password"
        )
        # Create a ContentPost with a uuid (assumed auto-generated by the model).
        self.post = ContentPost.objects.create(
            user=self.user, title="Detail Post", embedding=[0.1, 0.2, 0.3]
        )
        self.client = Client()

    def test_content_post_detail_view(self) -> None:
        """
        The content post detail view should return the correct post in context.
        """
        url = reverse("content-post-detail", kwargs={"uuid": self.post.uuid})
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context.get("post"), self.post)


class CreateContentPostViewTests(BaseTestCase):
    def setUp(self) -> None:
        self.user = User.objects.create_user(
            email="create@example.com", username="createuser", password="password"
        )
        self.client = Client()
        self.url = reverse("create-content-post")

    def test_create_content_post_view_get(self) -> None:
        """
        GET request to the create view should display the form.
        """
        self.client.login(email="create@example.com", password="password")
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        # Check that the form is present in the context.
        self.assertIn("form", response.context)

    @override_settings(MEDIA_ROOT="/tmp/django_test_media")
    def test_create_content_post_view_post(self) -> None:
        """
        POST request with valid data should create a ContentPost and redirect to its detail page.
        """
        self.client.login(email="create@example.com", password="password")
        data = {
            "title": "New Post",
            "description": "Test description",
            "media_type": "text",
            "text_content": "This is a test post.",
            # Assuming embedding can be blank; in production it's computed later.
        }
        response = self.client.post(self.url, data)
        # Expect a redirect on successful creation.
        self.assertEqual(response.status_code, 302)
        new_post = ContentPost.objects.get(title="New Post")
        self.assertEqual(new_post.text_content, "This is a test post.")
        # Check that the redirect URL is the post's detail page.
        expected_redirect = new_post.get_absolute_url()
        self.assertIn(expected_redirect, response.url)
